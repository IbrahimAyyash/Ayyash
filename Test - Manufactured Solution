%Manufactured solution
clear all; clc;
%Initial Values That Were Given In The Problem Statement That Dictate The
%Bounds For The Problem
ax = 0;
ay = 0;
bx = 2*pi;
by = 2*pi;

%The Number Of Nodes Used In Computing Of The Solution And The
%Incrementation Value That Was Used
n = 20;
m = 20;
dx = 1/n;
dy = 1/m;

%Computes The Coordinate Discretization Values That Are Used In The
%Solution And Places Them Into A 2-D Meshgrid To Be Called Upon Later
a = 1;
b = 1;
w = 1;

x = linspace(ax,bx,n+2);
y = linspace(ay,by,m+2);
[Y,X] = meshgrid(y,x);
F = ((a^2)+(w^2))*(-sin(a*X).*cos(w*(Y-b)));
F = -F;

%Coefficients Of The Node Values 
A = 1/(dx^2);
B = 1/(dy^2);
C = ((2/dx^2)+(2/dy^2));

%Setting Up A Global Solution Matrix The Contains All Nodular Solutions
U = ones(n+2,m+2);
U(:,1) = 0;                           %Left Side Boundary
U(:,end) = sin(2*pi*a)*cos(w*(y-b));  %Right Side Boundary
U(end,:) = sin(a*x)*cos(w*b);         %Bottom Side Boundary

Gausscounter = 0;
err = 1;
omega = 1;
z = -w*sin(a*x)*sin(w*((2*pi)-b));

%Guass-Sidel Solver
while err > 1e-6
D = U;
%Top-Side Boundary Condition
for j = 2:n+1
        U(1,j) = (-1/C)*(-F(1,j) - B*U(2,j) - B*(U(2,j)+(2*z(j)*dy)) - A*U(1,j-1) - A*U(1,j+1) );
end
for k = 2:m+1
    for j = 2:n+1
        U(j,k) = (-1/C)*(- F(j,k) - A*U(j,k-1) - B*U(j-1,k) - A*U(j,k+1) - B*U(j+1,k));
        U(j,k) = omega*U(j,k) + (1 - omega)*D(j,k);
        Gausscounter = Gausscounter + 1;
    end
end
err = max(max(abs((D-U)./D)));
end
surf(x,y,U)
disp('Computing Iterations:');
disp(Gausscounter);


R = ones(n+2,m+2);
for q = 1:n+2
    for p = 1:m+2
        R(p,q) = sin(a*x(q)).*cos(w*(y(p)-b));
        %R(p,q) = ((a^2)+(w^2))*(-sin(a*x(q))*cos(w*(y(p)-b)));
    end
end
% R(:,1) = 0;
% R(:,end) = sin(2*pi*a)*cos(w*(y-b));
% R(end,:) = sin(a*x)*cos(w*b);
% R(1,:) = -w*sin(a*x)*sin(w*((2*pi)-b));
figure
surf(x,y,R)

% PoissR = ((a^2)+(w^2))*(-sin(a*X)*cos(w*(Y-b)))

